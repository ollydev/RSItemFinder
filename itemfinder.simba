const
  ITEM_FINDER_IMAGE_PATH = {$macro CURRENT_DIRECTORY} + '/images/';
  ITEM_FINDER_ID_FILE = {$macro CURRENT_DIRECTORY} + '/itemid.txt';

type
  TRSItemFinder_Image = type TMufasaBitmap;

// Loads item image adding the item border if needed.
// Make sure item has a 1 px padding from the edge.
procedure TRSItemFinder_Image.Load(FilePath: String);

  function GetItemEdge(TPA: TPointArray): TPointArray;
  var
    Matrix: T2DBoolArray;
    Area: TBox;
    i, X, Y, W, H: Int32;
  begin
    Area := TPA.Bounds();

    SetLength(Matrix, Area.Height, Area.Width);
    for i := 0 to High(TPA) do
      Matrix[TPA[i].Y - Area.Y1][TPA[i].X - Area.X1] := True;

    W := High(Matrix[0]);
    H := High(Matrix);

    for i := 0 to High(TPA) do
    begin
      X := TPA[i].X - Area.X1;
      Y := TPA[i].Y - Area.Y1;

      if (X = 0) or (Y = 0) or (X = W) or (Y = H) then
        Continue;
      if Matrix[Y, X - 1] and Matrix[Y, X + 1] and Matrix[Y - 1, X] and Matrix[Y + 1, X] then
        Continue;

      Result := Result + TPA[i];
    end;
  end;

var
  TPA: TPointArray;
begin
  Self.Init(Client.GetMBitmaps());
  Self.LoadFromFile(FilePath);
  Self.ReplaceColor($FFFFFF, 0);

  if not Self.FindColors(TPA, $10000) and Self.FindColors(TPA, 0) then
    DrawTPA(GetItemEdge(TPA), $10000);
end;

type
  TRSItemFinder = record
    Similarity: Double;
    Images: array of TRSItemFinder_Image;
  end;

function TRSItemFinder.GetItemID(Identifer: String): Int32;
var
  Noted: Boolean;
  List: TStringList;
begin
  Identifer := StringReplace(Identifer, ' ', '_', [rfReplaceAll]).Lower();
  Noted := 'noted_' in Identifer
  if Noted then
    Identifer := StringReplace(Identifer, 'noted_', '', [rfIgnoreCase]);

  try
    Result := StrToInt(Identifer);
  except
    List.Init();

    try
      List.LoadFromFile(ITEM_FINDER_ID_FILE);
      if List.IndexOfName(Identifer) = -1 then
        raise 'Unknown item ID for: ' + Identifer;

      Result := StrToIntDef(List.GetValues(Identifer), -1);
    finally
      List.Free();
    end;

    if Noted then
      Result := Result + 1;
  end;
end;

function TRSItemFinder.Find(Identifer: String; Boxes: TBoxArray): TIntegerArray;

  function GetItemImage(Identifer: String): TRSItemFinder_Image;
  var
    i, ID: Int32;
    Image: TRSItemFinder_Image;
    TPA: TPointArray;
  begin
    for i := 0 to High(Images) do
      if (Images[i].GetName() = Identifer) then
        Exit(Images[i].Copy());

    Image.Load(Format('%s%d.png', [ITEM_FINDER_IMAGE_PATH, Self.GetItemID(Identifer)]));
    Image.SetName(Identifer);

    Image.FindColors(TPA, $10000);
    with TPA.Bounds() do
      Image.Crop(X1, Y1, X2, Y2);

    Self.Images := Self.Images + Image;

    Exit(Image.Copy());
  end;

  function GetItemStack(Image: TRSItemFinder_Image): TPointArray;
  var
    Color: Int32;
    TPA: TPointArray;
  begin
    for Color in [$FFFFFF, $00FFFF, $80FF00] do
      if Image.FindColors(TPA, Color) then
        Result := Result + TPA;

    TPA := Copy(Result);
    TPA.Offset(Point(1, 1));

    Result := Result + TPA;
  end;

  function GetItemEdge(Image: TRSItemFinder_Image): TPointArray;
  begin
    if Image.FindColors(Result, $10000) then
      Result := ClearTPAFromTPA(Result, GetItemStack(Image));
  end;

  procedure AlignTemplateToImage(Image: TRSItemFinder_Image; var Templ: TRSItemFinder_Image);
  var
    TPA: TPointArray;
    Replacement: TRSItemFinder_Image;
  begin
    Replacement.Init();
    Replacement.SetSize(Image.GetWidth(), Image.GetHeight());

    with GetItemEdge(Image).Bounds() do
      Templ.DrawTransparent(
        Max(0, X2 - Templ.GetWidth() + 1),
        Max(0, Y2 - Templ.GetHeight() + 1), Replacement
      );

    Templ.Free();
    Templ := Replacement;
  end;

  procedure ClearBackground(Template, Image: TRSItemFinder_Image);
  var
    TPA: TPointArray;
  begin
    if Image.FindColors(TPA, 0) then
      Template.DrawTPA(TPA, 0);

    if Image.FindColors(TPA, $202030) then // Noted item border
    begin
      Image.DrawTPA(TPA, 0);
      Template.DrawTPA(TPA, 0);
    end;
  end;

  procedure ClearStack(Image, Template: TRSItemFinder_Image);
  var
    P: TPoint;
  begin
    for P in GetItemStack(Template) do
    begin
      if Template.PointInBitmap(P.X, P.Y) then
        Template.SetPixel(P.X, P.Y, 0);
      if Image.PointInBitmap(P.X, P.Y) then
        Image.SetPixel(P.X, P.Y, 0);
    end;
  end;

var
  Image, Templ: TRSItemFinder_Image;
  Index: Int32;
begin
  for Index := 0 to High(Boxes) do
  begin
    Image := GetMufasaBitmap(BitmapFromClient(Boxes[Index]));
    Templ := GetItemImage(Identifer);

    AlignTemplateToImage(Image, Templ);
    ClearStack(Templ, Image);
    ClearBackground(Image, Templ);

    {$IFDEF ITEMFINDER_DEBUG}
    Image.SaveToFile('image.png');
    Templ.SaveToFile('templ.png');

    WriteLn Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0];

    TerminateScript();
    {$ENDIF}

    if Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0] >= Self.Similarity then
      Result := Result + Index;

    Image.Free();
    Templ.Free();
  end;
end;

procedure TRSItemFinder.Free;
var
  i: Int32;
begin
  for i := 0 to High(Images) do
    Images[i].Free();
end;

var
  ItemFinder: TRSItemFinder = [0.99997];

begin
  AddOnTerminate(@ItemFinder.Free);
end;

{$i itemfinder_finders.simba}
