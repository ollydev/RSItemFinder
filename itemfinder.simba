type
  TRSItemFinder_Image = type TMufasaBitmap;

// Loads item image adding the item border if needed.
// Make sure item has a 1 px padding from the edge.
procedure TRSItemFinder_Image.Load(FilePath: String);

  function GetItemEdge(TPA: TPointArray): TPointArray;
  var
    Matrix: T2DBoolArray;
    Area: TBox;
    i, X, Y, W, H: Int32;
  begin
    Area := TPA.Bounds();

    SetLength(Matrix, Area.Height, Area.Width);
    for i := 0 to High(TPA) do
      Matrix[TPA[i].Y - Area.Y1][TPA[i].X - Area.X1] := True;

    W := High(Matrix[0]);
    H := High(Matrix);

    for i := 0 to High(TPA) do
    begin
      X := TPA[i].X - Area.X1;
      Y := TPA[i].Y - Area.Y1;

      if (X = 0) or (Y = 0) or (X = W) or (Y = H) then
        Continue;
      if Matrix[Y, X - 1] and Matrix[Y, X + 1] and Matrix[Y - 1, X] and Matrix[Y + 1, X] then
        Continue;

      Result := Result + TPA[i];
    end;
  end;

var
  TPA: TPointArray;
begin
  Self.Init(Client.GetMBitmaps());
  Self.LoadFromFile(FilePath);
  Self.ReplaceColor($FFFFFF, 0);

  if not Self.FindColors(TPA, $10000) and Self.FindColors(TPA, 0) then
    DrawTPA(GetItemEdge(TPA), $10000);
end;

type
  TRSItemFinder = record
    ImagePath: String;
    Images: array of TRSItemFinder_Image;
    Similarity: Double;
  end;

function TRSItemFinder.Find(ID: String; Boxes: TBoxArray): TIntegerArray;

  function GetItemID(Identifer: String): String;
  var
    List: TStringList;
  begin
    List.Init();
    List.LoadFromFile(ImagePath + 'items.txt');
    if List.IndexOfName(Identifer) >= 0 then
      Result := List.GetValues(Identifer);
    List.Free();
  end;

  function GetItemImage(Identifer: String): TRSItemFinder_Image;
  var
    i: Int32;
    Image: TRSItemFinder_Image;
    TPA: TPointArray;
  begin
    for i := 0 to High(Images) do
      if (Images[i].GetName() = Identifer) then
        Exit(Images[i].Copy());

    try
      StrToInt(Identifer);
    except
      ID := GetItemID(Identifer);
      if ID = '' then
        raise 'Unknown item ID for: ' + Identifer;

      Image.Load(ImagePath + ID + '.png');
      Image.SetName(Identifer);
    end;

    if (Image = nil) then
    begin
      Image.Load(ImagePath + Identifer + '.png');
      Image.SetName(Identifer);
    end;

    Image.FindColors(TPA, $10000);
    with TPA.Bounds() do
      Image.Crop(X1, Y1, X2, Y2);

    Images += Image;

    Exit(Image.Copy());
  end;

  function GetItemStack(Image: TRSItemFinder_Image): TPointArray;
  var
    Color: Int32;
    TPA: TPointArray;
  begin
    for Color in [$FFFFFF, $00FFFF, $80FF00] do
      if Image.FindColors(TPA, Color) then
        Result := Result + TPA;

    TPA := Copy(Result);
    TPA.Offset(Point(1, 1));

    Result := Result + TPA;
  end;

  function GetItemEdge(Image: TRSItemFinder_Image): TPointArray;
  begin
    if Image.FindColors(Result, $10000) then
      Result := ClearTPAFromTPA(Result, GetItemStack(Image));
  end;

  procedure AlignTemplateToImage(Image: TRSItemFinder_Image; var Templ: TRSItemFinder_Image);
  var
    TPA: TPointArray;
    Replacement: TRSItemFinder_Image;
  begin
    Replacement.Init();
    Replacement.SetSize(Image.GetWidth(), Image.GetHeight());

    with GetItemEdge(Image).Bounds() do
      Templ.DrawTransparent(
        Max(0, X2 - Templ.GetWidth() + 1),
        Max(0, Y2 - Templ.GetHeight() + 1), Replacement
      );

    Templ.Free();
    Templ := Replacement;
  end;

  procedure ClearBackground(Template, Image: TRSItemFinder_Image);
  var
    TPA: TPointArray;
  begin
    if Image.FindColors(TPA, 0) then
      Template.DrawTPA(TPA, 0);
  end;

  procedure ClearStack(Image, Template: TRSItemFinder_Image);
  var
    P: TPoint;
  begin
    for P in GetItemStack(Template) do
    begin
      if Template.PointInBitmap(P.X, P.Y) then
        Template.SetPixel(P.X, P.Y, 0);
      if Image.PointInBitmap(P.X, P.Y) then
        Image.SetPixel(P.X, P.Y, 0);
    end;
  end;

var
  Image, Templ: TRSItemFinder_Image;
  Index: Int32;
begin
  for Index := 0 to High(Boxes) do
  begin
    Image := GetMufasaBitmap(BitmapFromClient(Boxes[Index]));
    Templ := GetItemImage(ID);

    AlignTemplateToImage(Image, Templ);
    ClearStack(Templ, Image);
    ClearBackground(Image, Templ);

    {$IFDEF ITEMFINDER_DEBUG}
    Image.SaveToFile('image.png');
    Templ.SaveToFile('templ.png');

    WriteLn Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0];

    TerminateScript();
    {$ENDIF}

    if Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0] >= Self.Similarity then
      Result := Result + Index;

    Image.Free();
    Templ.Free();
  end;
end;

procedure TRSItemFinder.Free;
var
  i: Int32;
begin
  for i := 0 to High(Images) do
    Images[i].Free();
end;

var
  ItemFinder: TRSItemFinder;

begin
  ItemFinder.Similarity := 0.99997;
  ItemFinder.ImagePath := IncludePath + 'RSItemFinder/item-images/';

  AddOnTerminate(@ItemFinder.Free);
end;

{$i itemfinder_finders.simba}
